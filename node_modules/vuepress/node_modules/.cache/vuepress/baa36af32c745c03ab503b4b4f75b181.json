{"remainingRequest":"E:\\github\\start-vuepress\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!E:\\github\\start-vuepress\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!E:\\github\\start-vuepress\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!E:\\github\\start-vuepress\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!E:\\github\\start-vuepress\\docs\\code\\mixin.md?vue&type=template&id=7f6d0419&","dependencies":[{"path":"E:\\github\\start-vuepress\\docs\\code\\mixin.md","mtime":1548645287700},{"path":"E:\\github\\start-vuepress\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\github\\start-vuepress\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"E:\\github\\start-vuepress\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\github\\start-vuepress\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"E:\\github\\start-vuepress\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"混入\\\"><a href=\\\"#混入\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 混入</h1> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://cn.vuejs.org/v2/guide/mixins.html\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"文档\"),_c('OutboundLink')],2)]),_vm._ssrNode(\" <ul><li><p>当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。</p></li> <li><p>混入对象的钩子将在组件自身钩子之前调用</p></li> <li><p>值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对</p></li></ul> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://blog.csdn.net/wangxiaoxiaosen/article/details/78487089\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"vue中watch的理解小记\"),_c('OutboundLink')],2)]),_vm._ssrNode(\" <ul><li><p>watch是一个对象</p></li> <li><p>键：就是你要监控的那个家伙，比如说$route，这个就是要监控路由的变化。或者是data中的某个变量</p></li> <li><p>值有三种情况：</p></li></ul> <ol><li><p>函数：就是当你监控的家伙变化时，需要执行的函数。这个函数有两个形参，第一个是当前值，第二个是变化后的值。</p></li> <li><p>函数名：不过这个函数名要用单引号来包裹。</p></li> <li><p>对象：有三个选项：\\n（1）handler：其值是一个回调函数。即监听到变化时应该执行的函数。\\n（2）deep：其值是true或false；确认是否深入监听。（一般监听时是不能监听到对象属性值的变化的，数组的值变化可以听到。\\n（3）immediate：其值是true或false；确认是否以当前的初始值执行handler的函数。</p></li></ol>\")],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}