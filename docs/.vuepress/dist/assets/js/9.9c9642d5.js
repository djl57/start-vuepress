(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{177:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包","aria-hidden":"true"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),e("h2",{attrs:{id:"什么是闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是闭包")]),t._v(" "),e("blockquote",[e("p",[t._v("闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。")])]),t._v(" "),e("h2",{attrs:{id:"闭包可能形成的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包可能形成的原因","aria-hidden":"true"}},[t._v("#")]),t._v(" 闭包可能形成的原因")]),t._v(" "),e("blockquote",[e("p",[t._v("在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作上值(upvalue)。")])]),t._v(" "),e("h2",{attrs:{id:"闭包与匿名函数区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包与匿名函数区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 闭包与匿名函数区别")]),t._v(" "),e("blockquote",[e("p",[t._v("闭包一词经常和匿名函数混淆。这可能是因为两者经常同时使用，但是它们是不同的概念")])]),t._v(" "),e("h2",{attrs:{id:"闭包的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包的作用","aria-hidden":"true"}},[t._v("#")]),t._v(" 闭包的作用")]),t._v(" "),e("blockquote",[e("p",[t._v("闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。变量的作用域仅限于包含它们的函数，因此无法从其它程序代码部分进行访问。不过，变量的生存期是可以很长，在一次函数调用期间所创建所生成的值在下次函数调用时仍然存在。正因为这一特点，闭包可以用来完成信息隐藏，并进而应用于需要状态表达的某些编程范型中。不过，用这种方式来使用闭包时，闭包不再具有引用透明性，因此也不再是纯函数。")])])])}],!1,null,null,null);s.options.__file="bibao.md";a.default=s.exports}}]);